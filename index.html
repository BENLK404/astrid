<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üíñ Astrid - Univers Immersif Ultime üíñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Impact', 'Arial Black', sans-serif;
            touch-action: none;
            cursor: grab;
        }

        body.grabbing {
            cursor: grabbing;
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.3) 100%);
            pointer-events: none;
            z-index: 5;
        }

        .name-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            perspective: 1000px;
            width: 90%;
            pointer-events: none;
        }

        .name {
            font-size: clamp(50px, 15vw, 150px);
            font-weight: 900;
            letter-spacing: 0.1em;
            background: linear-gradient(45deg,
            #ff0080, #ff8c00, #40e0d0, #9d00ff,
            #ff0080, #ff8c00, #40e0d0);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation:
                    megaGradient 4s ease infinite,
                    explosive 6s ease-in-out infinite;
            filter:
                    drop-shadow(0 0 40px rgba(255, 0, 128, 0.9))
                    drop-shadow(0 0 60px rgba(157, 0, 255, 0.7))
                    drop-shadow(0 0 80px rgba(64, 224, 208, 0.5));
            transform-style: preserve-3d;
        }

        @keyframes megaGradient {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        @keyframes explosive {
            0%, 100% {
                transform: scale(1) translateY(0) rotateX(0deg);
            }
            25% {
                transform: scale(1.15) translateY(-30px) rotateX(15deg);
            }
            50% {
                transform: scale(0.95) translateY(0) rotateX(-10deg);
            }
            75% {
                transform: scale(1.1) translateY(-20px) rotateX(10deg);
            }
        }

        .particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .subtitle {
            margin-top: clamp(20px, 5vh, 50px);
            font-size: clamp(18px, 4vw, 32px);
            color: white;
            font-weight: bold;
            animation: pulse 2s ease-in-out infinite;
            text-shadow:
                    0 0 20px rgba(255, 255, 255, 1),
                    0 0 40px rgba(255, 0, 128, 0.8),
                    0 0 60px rgba(157, 0, 255, 0.6);
            letter-spacing: 0.2em;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        .stars {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 2;
        }

        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
            box-shadow: 0 0 10px white;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .lightning {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            animation: flash 5s infinite;
        }

        @keyframes flash {
            0%, 90%, 100% { opacity: 0; }
            92%, 94%, 96% { opacity: 0.8; }
        }

        .ring {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            margin: -100px 0 0 -100px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
            z-index: 4;
            pointer-events: none;
        }

        @keyframes expandRing {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .controls {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 20;
            background: rgba(0,0,0,0.7);
            padding: 1rem 2rem;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .control-btn {
            padding: 0.8rem 1.5rem;
            background: linear-gradient(135deg, #ff0080, #9d00ff);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: clamp(0.8rem, 2vw, 1rem);
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(255, 0, 128, 0.5);
        }

        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.8);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .zoom-indicator {
            position: fixed;
            top: 5%;
            right: 5%;
            color: white;
            font-size: clamp(0.8rem, 2vw, 1rem);
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            z-index: 20;
            font-family: 'Courier New', monospace;
            border: 2px solid rgba(255,255,255,0.2);
            text-shadow: 0 0 10px rgba(255,0,128,0.8);
        }

        .instructions {
            position: fixed;
            top: 5%;
            left: 5%;
            color: white;
            font-size: clamp(0.7rem, 1.8vw, 0.9rem);
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            border-radius: 15px;
            z-index: 20;
            font-family: 'Arial', sans-serif;
            border: 2px solid rgba(255,255,255,0.2);
            max-width: 250px;
            line-height: 1.5;
        }

        .explosion-particle {
            position: fixed;
            pointer-events: none;
            z-index: 15;
            animation: explode 1s ease-out forwards;
        }

        @keyframes explode {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .name {
                font-size: clamp(40px, 12vw, 80px);
            }

            .controls {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.8rem 1.5rem;
            }

            .control-btn {
                padding: 0.6rem 1rem;
            }

            .instructions {
                font-size: 0.7rem;
                padding: 0.8rem;
                max-width: 180px;
            }
        }
    </style>
</head>
<body>
<canvas id="canvas3d"></canvas>
<canvas class="particles-canvas" id="particlesCanvas"></canvas>
<div class="overlay"></div>
<div class="stars" id="starsContainer"></div>
<div class="lightning"></div>
<div class="ring"></div>
<div class="ring" style="animation-delay: 1s;"></div>
<div class="ring" style="animation-delay: 2s;"></div>

<div class="name-container">
    <div class="subtitle">‚òÖ Mon Univers Infini ‚òÖ</div>
</div>

<div class="instructions">
    üñ±Ô∏è Glisser pour tourner<br>
    üîç Molette/Pincer pour zoomer<br>
    üëÜ Cliquer pour explosions<br>
    üéØ Boutons pour vues rapides<br>
    ‚àû Zoom infini activ√©!
</div>

<div class="zoom-indicator">
    ZOOM: <span id="zoomLevel">100%</span>
</div>

<div class="controls">
    <button class="control-btn" id="resetBtn">üîÑ Reset</button>
    <button class="control-btn" id="closeBtn">üîç Max Zoom</button>
    <button class="control-btn" id="farBtn">üåå Vue Large</button>
    <button class="control-btn" id="topBtn">‚¨ÜÔ∏è Vue Haut</button>
    <button class="control-btn" id="leftBtn">‚¨ÖÔ∏è Gauche</button>
    <button class="control-btn" id="rightBtn">‚û°Ô∏è Droite</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // √âtoiles scintillantes
    const starsContainer = document.getElementById('starsContainer');
    for (let i = 0; i < 200; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        star.style.animationDuration = (Math.random() * 2 + 2) + 's';
        starsContainer.appendChild(star);
    }

    // Canvas pour particules
    const particlesCanvas = document.getElementById('particlesCanvas');
    const pCtx = particlesCanvas.getContext('2d');
    particlesCanvas.width = window.innerWidth;
    particlesCanvas.height = window.innerHeight;

    const particles = [];
    class Particle {
        constructor() {
            this.reset();
        }
        reset() {
            this.x = Math.random() * particlesCanvas.width;
            this.y = Math.random() * particlesCanvas.height;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            this.life = Math.random() * 100 + 100;
            this.maxLife = this.life;
            this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
            this.size = Math.random() * 3 + 1;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            if (this.life <= 0) this.reset();
        }
        draw() {
            pCtx.globalAlpha = this.life / this.maxLife;
            pCtx.fillStyle = this.color;
            pCtx.shadowBlur = 20;
            pCtx.shadowColor = this.color;
            pCtx.beginPath();
            pCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            pCtx.fill();
        }
    }

    for (let i = 0; i < 250; i++) {
        particles.push(new Particle());
    }

    function animateParticles() {
        pCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        particles.forEach(p => {
            p.update();
            p.draw();
        });
        requestAnimationFrame(animateParticles);
    }
    animateParticles();

    // Three.js - Configuration
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('canvas3d'),
        alpha: true,
        antialias: !isMobile
    });

    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    camera.position.z = 30;

    // √âNORM√âMENT de g√©om√©tries complexes distribu√©es dans l'espace
    const geometries = [
        new THREE.IcosahedronGeometry(8, 1),
        new THREE.TorusGeometry(8, 3, 16, 100),
        new THREE.OctahedronGeometry(10, 0),
        new THREE.TetrahedronGeometry(7, 0),
        new THREE.DodecahedronGeometry(6, 0),
        new THREE.TorusKnotGeometry(5, 2, 100, 16),
        new THREE.SphereGeometry(6, 32, 32),
        new THREE.ConeGeometry(5, 10, 32),
        new THREE.CylinderGeometry(3, 3, 10, 32),
        new THREE.BoxGeometry(8, 8, 8)
    ];

    const mainMeshes = [];
    const colors = [0xff0080, 0x40e0d0, 0x9d00ff, 0xff8c00, 0x00ff00, 0xff1493, 0x00ffff, 0xffd700, 0xff69b4, 0x7fff00];

    // Cr√©er 5 couches d'objets √† diff√©rentes distances
    for (let layer = 0; layer < 5; layer++) {
        const radius = 20 + layer * 30;
        const objectsInLayer = 20 + layer * 15;

        for (let i = 0; i < objectsInLayer; i++) {
            const geom = geometries[Math.floor(Math.random() * geometries.length)].clone();
            const colorIdx = Math.floor(Math.random() * colors.length);

            const mat = new THREE.MeshPhongMaterial({
                color: colors[colorIdx],
                wireframe: Math.random() > 0.5,
                transparent: true,
                opacity: 0.3 + Math.random() * 0.4,
                emissive: colors[colorIdx],
                emissiveIntensity: 0.3 + Math.random() * 0.4
            });

            const mesh = new THREE.Mesh(geom, mat);

            // Distribution sph√©rique
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;

            mesh.position.x = radius * Math.sin(theta) * Math.cos(phi);
            mesh.position.y = radius * Math.sin(theta) * Math.sin(phi);
            mesh.position.z = radius * Math.cos(theta) - 20 - layer * 20;

            mesh.scale.set(
                0.5 + Math.random() * 1.5,
                0.5 + Math.random() * 1.5,
                0.5 + Math.random() * 1.5
            );

            mesh.userData = {
                originalPosition: mesh.position.clone(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                oscillation: {
                    amplitude: Math.random() * 10 + 5,
                    speed: Math.random() * 2 + 1,
                    offset: Math.random() * Math.PI * 2
                }
            };
            mainMeshes.push(mesh);
            scene.add(mesh);
        }
    }

    // √âNORME nuage de points lumineux - plusieurs couches
    const pointsClouds = [];
    for (let cloud = 0; cloud < 7; cloud++) {
        const pointsGeometry = new THREE.BufferGeometry();
        const pointsCount = isMobile ? 3000 : 8000;
        const positions = new Float32Array(pointsCount * 3);
        const colors = new Float32Array(pointsCount * 3);
        const spread = 150 + cloud * 80;

        for (let i = 0; i < pointsCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * spread;
            positions[i + 1] = (Math.random() - 0.5) * spread;
            positions[i + 2] = (Math.random() - 0.5) * spread;

            const color = new THREE.Color();
            color.setHSL(Math.random(), 1, 0.6 + Math.random() * 0.3);
            colors[i] = color.r;
            colors[i + 1] = color.g;
            colors[i + 2] = color.b;
        }

        pointsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        pointsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const pointsMaterial = new THREE.PointsMaterial({
            size: 0.2 + cloud * 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const pointsCloud = new THREE.Points(pointsGeometry, pointsMaterial);
        pointsCloud.userData = {
            rotationSpeed: {
                x: (Math.random() - 0.5) * 0.001,
                y: (Math.random() - 0.5) * 0.001,
                z: (Math.random() - 0.5) * 0.001
            }
        };
        pointsClouds.push(pointsCloud);
        scene.add(pointsCloud);
    }

    // Lumi√®res dynamiques suppl√©mentaires
    const lights = [];
    const lightColors = [0xff0080, 0x40e0d0, 0x9d00ff, 0xff8c00, 0x00ff00, 0xff1493, 0x00ffff, 0xffd700];
    for (let i = 0; i < 8; i++) {
        const light = new THREE.PointLight(lightColors[i], 2, 150);
        lights.push(light);
        scene.add(light);
    }

    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);

    // Variables de contr√¥le avec zoom infini
    let time = 0;
    let mouseX = 0;
    let mouseY = 0;
    let targetX = 0;
    let targetY = 0;
    let targetZoom = 30;
    let currentZoom = 30;
    let isDragging = false;
    let previousMouse = { x: 0, y: 0 };
    let rotationX = 0;
    let rotationY = 0;

    // Gestion du drag
    const canvas = document.getElementById('canvas3d');

    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        document.body.classList.add('grabbing');
        previousMouse = { x: e.clientX, y: e.clientY };
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const deltaX = e.clientX - previousMouse.x;
            const deltaY = e.clientY - previousMouse.y;
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            previousMouse = { x: e.clientX, y: e.clientY };
        } else {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.classList.remove('grabbing');
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        document.body.classList.remove('grabbing');
    });

    // Touch events
    let touchDistance = 0;
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            touchDistance = Math.sqrt(dx * dx + dy * dy);
        }
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 1 && isDragging) {
            const deltaX = e.touches[0].clientX - previousMouse.x;
            const deltaY = e.touches[0].clientY - previousMouse.y;
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const delta = distance - touchDistance;
            targetZoom -= delta * 0.05;
            targetZoom = Math.max(1, Math.min(500, targetZoom));
            touchDistance = distance;
        }
    });

    canvas.addEventListener('touchend', () => {
        isDragging = false;
    });

    // Zoom avec molette - INFINI
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        targetZoom += e.deltaY * 0.05;
        targetZoom = Math.max(1, Math.min(500, targetZoom));
    }, { passive: false });

    // Boutons de contr√¥le
    document.getElementById('resetBtn').addEventListener('click', () => {
        targetZoom = 30;
        rotationX = 0;
        rotationY = 0;
        camera.position.set(0, 0, 30);
    });

    document.getElementById('closeBtn').addEventListener('click', () => {
        targetZoom = 3;
    });

    document.getElementById('farBtn').addEventListener('click', () => {
        targetZoom = 200;
    });

    document.getElementById('topBtn').addEventListener('click', () => {
        rotationX = -Math.PI / 3;
        rotationY = 0;
    });

    document.getElementById('leftBtn').addEventListener('click', () => {
        rotationY -= Math.PI / 4;
    });

    document.getElementById('rightBtn').addEventListener('click', () => {
        rotationY += Math.PI / 4;
    });

    // Mise √† jour du zoom indicator
    function updateZoomIndicator() {
        const zoomPercent = Math.round((30 / currentZoom) * 100);
        document.getElementById('zoomLevel').textContent = zoomPercent + '%';
    }

    // Animation principale
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        // Zoom fluide
        currentZoom += (targetZoom - currentZoom) * 0.1;

        // Position de la cam√©ra avec rotation
        const radius = currentZoom;
        camera.position.x = Math.sin(rotationY) * Math.cos(rotationX) * radius;
        camera.position.y = Math.sin(rotationX) * radius;
        camera.position.z = Math.cos(rotationY) * Math.cos(rotationX) * radius;

        // Mouvement subtil si pas de drag
        if (!isDragging) {
            targetX += (mouseX - targetX) * 0.05;
            targetY += (mouseY - targetY) * 0.05;
            camera.position.x += targetX * 2;
            camera.position.y += -targetY * 2;
        }

        camera.lookAt(scene.position);
        updateZoomIndicator();

        // Animation des formes avec mouvement individuel
        mainMeshes.forEach((mesh, i) => {
            const userData = mesh.userData;
            mesh.rotation.x += userData.rotationSpeed.x;
            mesh.rotation.y += userData.rotationSpeed.y;
            mesh.rotation.z += userData.rotationSpeed.z;

            const osc = userData.oscillation;
            mesh.position.y = userData.originalPosition.y + Math.sin(time * osc.speed + osc.offset) * osc.amplitude;
            mesh.position.x = userData.originalPosition.x + Math.cos(time * osc.speed * 0.7 + osc.offset) * osc.amplitude * 0.5;

            const scaleOsc = 1 + Math.sin(time * 2 + i * 0.1) * 0.2;
            mesh.scale.set(scaleOsc, scaleOsc, scaleOsc);
        });

        // Animation des nuages de points
        pointsClouds.forEach((cloud, i) => {
            const speed = cloud.userData.rotationSpeed;
            cloud.rotation.x += speed.x;
            cloud.rotation.y += speed.y;
            cloud.rotation.z += speed.z;
        });

        // Animation des lumi√®res en spirale
        lights.forEach((light, i) => {
            const angle = time + (i * Math.PI * 2 / lights.length);
            const radius = 30 + i * 5;
            light.position.x = Math.cos(angle) * radius;
            light.position.y = Math.sin(angle * 1.5) * radius;
            light.position.z = Math.sin(angle) * radius;
            light.intensity = 2 + Math.sin(time * 3 + i) * 1.5;
        });

        renderer.render(scene, camera);
    }
    animate();

    // Effet explosion au clic
    function createExplosion(x, y) {
        for (let i = 0; i < 50; i++) {
            const particle = document.createElement('div');
            particle.className = 'explosion-particle';
            particle.style.left = x + 'px';
            particle.style.top = y + 'px';
            particle.style.width = (Math.random() * 8 + 4) + 'px';
            particle.style.height = particle.style.width;
            particle.style.background = `hsl(${Math.random() * 360}, 100%, 70%)`;
            particle.style.borderRadius = '50%';
            particle.style.boxShadow = `0 0 10px ${particle.style.background}`;

            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 300 + 100;
            particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
            particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');

            document.body.appendChild(particle);
            setTimeout(() => particle.remove(), 1000);
        }

        // Particules canvas
        for (let i = 0; i < 30; i++) {
            const p = new Particle();
            p.x = x;
            p.y = y;
            p.vx = (Math.random() - 0.5) * 10;
            p.vy = (Math.random() - 0.5) * 10;
            p.size = Math.random() * 5 + 2;
            particles.push(p);
        }
    }

    canvas.addEventListener('click', (e) => createExplosion(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches[0] && e.touches.length === 1) {
            setTimeout(() => {
                if (!isDragging) {
                    createExplosion(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, 100);
        }
    });

    // Responsive
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;
    });
</script>
</body>
</html>
