<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>✨ Constellation d'Amour pour Astrid ✨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: white;
            touch-action: none;
        }

        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0033, #330066, #1a0033);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 1.5s ease;
        }

        .welcome-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .logo {
            font-size: clamp(3rem, 12vw, 8rem);
            font-weight: bold;
            text-align: center;
            margin-bottom: 2rem;
            position: relative;
        }

        .logo-letter {
            display: inline-block;
            animation: float 3s ease-in-out infinite;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: float 3s ease-in-out infinite, gradientFlow 4s ease infinite;
            filter: drop-shadow(0 0 20px rgba(255,0,255,0.5));
        }

        .logo-letter:nth-child(1) { animation-delay: 0s; }
        .logo-letter:nth-child(2) { animation-delay: 0.1s; }
        .logo-letter:nth-child(3) { animation-delay: 0.2s; }
        .logo-letter:nth-child(4) { animation-delay: 0.3s; }
        .logo-letter:nth-child(5) { animation-delay: 0.4s; }
        .logo-letter:nth-child(6) { animation-delay: 0.5s; }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: rgba(255,255,255,0.8);
            margin-bottom: 3rem;
            text-align: center;
            padding: 0 2rem;
        }

        .enter-button {
            padding: 1.5rem 4rem;
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            background: transparent;
            border: 3px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.2em;
        }

        .enter-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }

        .enter-button:hover::before {
            left: 100%;
        }

        .enter-button:hover {
            box-shadow: 0 0 30px rgba(0,255,255,0.8), inset 0 0 20px rgba(0,255,255,0.2);
            transform: scale(1.05);
        }

        .hud {
            position: fixed;
            top: 3%;
            left: 3%;
            font-family: 'Courier New', monospace;
            color: #00ffff;
            z-index: 10;
            font-size: clamp(0.8rem, 2vw, 1rem);
            text-shadow: 0 0 10px rgba(0,255,255,0.8);
            opacity: 0;
            transition: opacity 1s ease;
        }

        .hud.active {
            opacity: 1;
        }

        .hud-line {
            margin: 0.3rem 0;
            font-weight: bold;
        }

        .message-container {
            position: fixed;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 700px;
            text-align: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .message-container.active {
            opacity: 1;
        }

        .message-box {
            background: rgba(0,0,0,0.8);
            border: 2px solid #ff00ff;
            padding: 1.5rem;
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            color: #ffffff;
            box-shadow: 0 0 30px rgba(255,0,255,0.5), inset 0 0 20px rgba(255,0,255,0.1);
            font-family: 'Courier New', monospace;
            line-height: 1.8;
        }

        .typing-cursor {
            display: inline-block;
            width: 0.6em;
            height: 1em;
            background: #00ffff;
            animation: blink 1s step-end infinite;
            margin-left: 0.1em;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        .progress-bar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.5);
            z-index: 10;
            opacity: 0;
        }

        .progress-bar-container.active {
            opacity: 1;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0,255,255,0.8);
        }

        .interaction-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(1.2rem, 4vw, 2rem);
            color: #00ffff;
            text-shadow: 0 0 20px rgba(0,255,255,0.8);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            font-weight: bold;
            text-align: center;
        }

        .interaction-hint.show {
            animation: hintPulse 2s ease-out;
        }

        @keyframes hintPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .portal-ring {
            position: fixed;
            border: 3px solid;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            animation: portalExpand 1.5s ease-out forwards;
        }

        @keyframes portalExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            opacity: 0.3;
            animation: scan 4s linear infinite;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(100vh); }
        }

        @media (max-width: 768px) {
            .enter-button {
                padding: 1rem 2rem;
            }

            .message-box {
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
<div class="welcome-screen" id="welcomeScreen">
    <div class="logo">
        <span class="logo-letter">A</span>
        <span class="logo-letter">S</span>
        <span class="logo-letter">T</span>
        <span class="logo-letter">R</span>
        <span class="logo-letter">I</span>
        <span class="logo-letter">D</span>
    </div>
    <div class="subtitle">[ INITIALISATION DE LA SÉQUENCE COSMIQUE ]</div>
    <button class="enter-button" id="enterBtn">ENTRER</button>
</div>

<div class="vignette"></div>
<div class="scan-line"></div>

<div class="progress-bar-container" id="progressContainer">
    <div class="progress-bar" id="progressBar"></div>
</div>

<div class="hud" id="hud">
    <div class="hud-line">SYSTÈME: <span style="color: #00ff00;">ACTIF</span></div>
    <div class="hud-line">CONNEXIONS: <span id="connectionCount">0</span></div>
    <div class="hud-line">DIMENSION: <span id="dimensionLevel">ALPHA</span></div>
</div>

<div class="message-container" id="messageContainer">
    <div class="message-box">
        <span id="messageText"></span>
        <span class="typing-cursor"></span>
    </div>
</div>

<div class="interaction-hint" id="interactionHint">+ CONNECTION ÉTABLIE +</div>

<canvas id="canvas3d"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let experienceStarted = false;
    let connectionCount = 0;
    let currentDimension = 0;
    const dimensions = ['ALPHA', 'BETA', 'GAMMA', 'DELTA', 'OMEGA'];

    const messages = [
        "TRANSMISSION REÇUE... Dans l'infini de l'espace, une seule vérité existe...",
        "ANALYSE EN COURS... Chaque constellation porte ton nom, Astrid...",
        "SYNCHRONISATION... Nos âmes résonnent à la même fréquence...",
        "DÉCOUVERTE... Tu es le centre de mon univers...",
        "RÉVÉLATION FINALE... Cet amour transcende les dimensions et le temps..."
    ];

    let currentMessage = 0;
    let typingInterval;

    // Bouton d'entrée
    document.getElementById('enterBtn').addEventListener('click', () => {
        document.getElementById('welcomeScreen').classList.add('fade-out');
        setTimeout(() => {
            experienceStarted = true;
            document.getElementById('hud').classList.add('active');
            document.getElementById('progressContainer').classList.add('active');
            showMessage();
        }, 1500);
    });

    // Configuration Three.js
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000033, 0.0008);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 50);

    const renderer = new THREE.WebGLRenderer({
        antialias: !isMobile,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    document.getElementById('canvas3d').appendChild(renderer.domElement);

    // Contrôles de caméra
    let cameraTarget = new THREE.Vector3(0, 0, 0);
    let cameraVelocity = new THREE.Vector3(0, 0, 0);
    let mouseX = 0, mouseY = 0;
    let targetCameraZ = 50;

    document.addEventListener('mousemove', (e) => {
        if (experienceStarted) {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        }
    });

    document.addEventListener('touchmove', (e) => {
        if (experienceStarted && e.touches[0]) {
            mouseX = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
        }
    });

    // Zoom avec molette/pinch
    document.addEventListener('wheel', (e) => {
        if (experienceStarted) {
            e.preventDefault();
            targetCameraZ += e.deltaY * 0.05;
            targetCameraZ = Math.max(20, Math.min(100, targetCameraZ));
        }
    }, { passive: false });

    let touchDist = 0;
    document.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            touchDist = Math.sqrt(dx * dx + dy * dy);
        }
    });

    document.addEventListener('touchmove', (e) => {
        if (experienceStarted && e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const delta = dist - touchDist;
            targetCameraZ -= delta * 0.1;
            targetCameraZ = Math.max(20, Math.min(100, targetCameraZ));
            touchDist = dist;
        }
    });

    // Création de tunnels de lumière
    const tunnelGeometry = new THREE.TorusGeometry(15, 0.3, 16, 100);
    const tunnels = [];

    for (let i = 0; i < 20; i++) {
        const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.5 + i * 0.02, 1, 0.5),
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });

        const tunnel = new THREE.Mesh(tunnelGeometry, material);
        tunnel.position.z = -i * 10;
        tunnel.userData.originalZ = -i * 10;
        tunnels.push(tunnel);
        scene.add(tunnel);
    }

    // Particules quantiques
    const particleCount = isMobile ? 2000 : 5000;
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const radius = Math.random() * 100;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI * 2;

        positions[i3] = radius * Math.sin(theta) * Math.cos(phi);
        positions[i3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
        positions[i3 + 2] = radius * Math.cos(theta) - 50;

        const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;

        sizes[i] = Math.random() * 2 + 0.5;
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

    const particleMaterial = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });

    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // Sphères énergétiques
    const spheres = [];
    const sphereCount = isMobile ? 8 : 15;

    for (let i = 0; i < sphereCount; i++) {
        const geometry = new THREE.SphereGeometry(Math.random() * 2 + 1, 16, 16);
        const material = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
            transparent: true,
            opacity: 0.4,
            wireframe: true
        });

        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 60,
            (Math.random() - 0.5) * 60 - 20
        );
        sphere.userData.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.1
        );
        spheres.push(sphere);
        scene.add(sphere);
    }

    // Interaction: clic/tap pour créer des portails
    function createPortal(x, y) {
        connectionCount++;
        document.getElementById('connectionCount').textContent = connectionCount;

        if (connectionCount % 10 === 0 && currentDimension < dimensions.length - 1) {
            currentDimension++;
            document.getElementById('dimensionLevel').textContent = dimensions[currentDimension];
            showMessage();
        }

        updateProgress();

        const portal = document.createElement('div');
        portal.className = 'portal-ring';
        portal.style.left = (x - 150) + 'px';
        portal.style.top = (y - 150) + 'px';
        portal.style.borderColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
        document.body.appendChild(portal);

        setTimeout(() => portal.remove(), 1500);

        const hint = document.getElementById('interactionHint');
        hint.classList.remove('show');
        void hint.offsetWidth;
        hint.classList.add('show');

        // Créer une onde dans l'espace
        const waveGeometry = new THREE.RingGeometry(0.5, 1, 32);
        const waveMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const wave = new THREE.Mesh(waveGeometry, waveMaterial);

        const vector = new THREE.Vector3(
            (x / window.innerWidth) * 2 - 1,
            -(y / window.innerHeight) * 2 + 1,
            0.5
        );
        vector.unproject(camera);
        vector.sub(camera.position).normalize();
        const distance = -camera.position.z / vector.z;
        wave.position.copy(camera.position.clone().add(vector.multiplyScalar(distance)));

        scene.add(wave);

        let scale = 1;
        const expandWave = () => {
            scale += 0.5;
            wave.scale.set(scale, scale, 1);
            wave.material.opacity -= 0.02;

            if (wave.material.opacity > 0) {
                requestAnimationFrame(expandWave);
            } else {
                scene.remove(wave);
                wave.geometry.dispose();
                wave.material.dispose();
            }
        };
        expandWave();
    }

    renderer.domElement.addEventListener('click', (e) => {
        if (experienceStarted) createPortal(e.clientX, e.clientY);
    });

    renderer.domElement.addEventListener('touchstart', (e) => {
        if (experienceStarted && e.touches[0]) {
            createPortal(e.touches[0].clientX, e.touches[0].clientY);
        }
    });

    // Affichage des messages avec effet de frappe
    function showMessage() {
        if (currentMessage >= messages.length) {
            currentMessage = 0;
        }

        const container = document.getElementById('messageContainer');
        const textEl = document.getElementById('messageText');

        container.classList.remove('active');

        setTimeout(() => {
            textEl.textContent = '';
            container.classList.add('active');

            let charIndex = 0;
            const text = messages[currentMessage];

            clearInterval(typingInterval);
            typingInterval = setInterval(() => {
                if (charIndex < text.length) {
                    textEl.textContent += text[charIndex];
                    charIndex++;
                } else {
                    clearInterval(typingInterval);
                    setTimeout(() => {
                        container.classList.remove('active');
                        currentMessage++;
                    }, 5000);
                }
            }, 50);
        }, 500);
    }

    // Mise à jour de la barre de progression
    function updateProgress() {
        const progress = (connectionCount / 50) * 100;
        document.getElementById('progressBar').style.width = Math.min(progress, 100) + '%';
    }

    // Animation principale
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        time += 0.01;

        if (experienceStarted) {
            // Mouvement fluide de la caméra
            cameraTarget.x = mouseX * 10;
            cameraTarget.y = mouseY * 10;

            camera.position.x += (cameraTarget.x - camera.position.x) * 0.05;
            camera.position.y += (cameraTarget.y - camera.position.y) * 0.05;
            camera.position.z += (targetCameraZ - camera.position.z) * 0.05;

            camera.lookAt(0, 0, 0);

            // Animation des tunnels
            tunnels.forEach((tunnel, i) => {
                tunnel.position.z += 0.5;
                if (tunnel.position.z > 10) {
                    tunnel.position.z = tunnel.userData.originalZ;
                }
                tunnel.rotation.z += 0.01;

                const hue = (0.5 + i * 0.02 + time * 0.1) % 1;
                tunnel.material.color.setHSL(hue, 1, 0.5);
            });

            // Animation des particules
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] += 0.2;
                if (positions[i + 2] > 50) {
                    positions[i + 2] = -100;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = time * 0.1;

            // Animation des sphères
            spheres.forEach(sphere => {
                sphere.position.add(sphere.userData.velocity);
                sphere.rotation.x += 0.01;
                sphere.rotation.y += 0.02;

                if (Math.abs(sphere.position.x) > 40) sphere.userData.velocity.x *= -1;
                if (Math.abs(sphere.position.y) > 40) sphere.userData.velocity.y *= -1;
                if (Math.abs(sphere.position.z) > 40) sphere.userData.velocity.z *= -1;

                const hue = (time + sphere.position.x * 0.01) % 1;
                sphere.material.color.setHSL(hue, 1, 0.5);
            });
        }

        renderer.render(scene, camera);
    }
    animate();

    // Responsive
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>